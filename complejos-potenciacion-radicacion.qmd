---
title: "Potenciación y radicación de números complejos"
---

## Introducción
La radicación y la potenciación de números complejos extienden las operaciones reales al plano complejo.  
En **forma polar**, todo número complejo puede escribirse como
$$
z \;=\; r(\cos\theta + i\sin\theta) \;=\; r\,e^{i\theta},
$$
donde $r=|z|$ es el **módulo** y $theta=arg(z)$ es el **argumento**.

El **Teorema de De Moivre** establece que
$$
(\cos\theta + i\sin\theta)^n \;=\; \cos(n\theta) + i\sin(n\theta),
$$
y en forma exponencial 
$$(e^{i\theta})^n = e^{in\theta}$$

## Teorema de De Moivre (raíces cuartas de $z$ )
Sean $z=re^{i\theta}$ y $n\in\mathbb{N}$. Las $n$-ésimas raíces de $z$ están dadas por
$$
w_k \;=\; r^{1/n}\,e^{\,i\frac{\theta+2\pi k}{n}},\qquad k=0,1,\dots,n-1.
$$
Para $n=4$:
$$
w_k \;=\; r^{1/4}\,e^{\,i\frac{\theta+2\pi k}{4}},\qquad k=0,1,2,3.
$$

# Verificación numérica por codigo:
Cada raíz debe cumplir $w^n ≈ z$
```{python}
# Cálculo de raíces n-ésimas con De Moivre
import cmath, math #Librerias

def raices_n_esimas(z: complex, n: int):
    """
    Devuelve la lista [w_0, ..., w_{n-1}] de raíces n-ésimas de z,
    usando la forma polar y De Moivre:
       w_k = |z|^(1/n) * exp( i*(arg(z) + 2πk)/n ),  k=0..n-1
    """
    r, th = abs(z), cmath.phase(z)
    return [(r**(1/n)) * cmath.exp(1j * (th + 2*math.pi*k) / n) for k in range(n)]

# --- Ejemplo del ejercicio: z = (16 i)/(1 + i), n = 8 ---
z = (16j) / (1 + 1j) #debemos reemplazar i por j en Python
n = 8
W = raices_n_esimas(z, n)

# Verificación numérica: cada raíz debe cumplir w^n ≈ z
residuos = [abs(w**n - z) for w in W]
print("Residuos:",[f"{r:.2e}" for r in residuos])
```

## Aplicación ejercicio 13:
**Simplificación**

$$
(\frac{16i}{1+i})^{1/8}
=(\frac{16i(1-i)}{(1+i)(1-i)})^{1/8}
=8(1±i)^{1/8}
$$

En forma polar de $z$
$$
1+i=\sqrt2\,e^{i\pi/4}\quad\Rightarrow\quad
z=8\sqrt2\,e^{i\pi/4}.
$$

$$|z|=8\sqrt2\quad\Rightarrow\quad Modulo$$
$$z = pi/4\quad\Rightarrow\quad Argumento principal$$

Por tanto, si $z=8\sqrt2\,e^{i\pi/4}$, sus **ocho raices octavas** son: 

$n=8$

$$
\boxed{w_k= (8\sqrt2)^{1/8}\,e^{\,i\left(\frac{\pi}{32}+\frac{k\pi}{4}\right)},
\qquad k=0,1,\dots,7.}
$$

Como $(8\sqrt2)^{1/8}=2^{7/16}$, el radio comun es:
$$
\boxed{\,w_k=2^{7/16}\Big[\cos\!\Big(\tfrac{\pi}{32}+\tfrac{k\pi}{4}\Big)
+i\sin\!\Big(\tfrac{\pi}{32}+\tfrac{k\pi}{4}\Big)\Big],\;k=0,\ldots,7.}
$$

## Raíz cuarta principal

La **raíz principal** se obtiene con el **argumento principal** ${Arg}(z)$ y $k=0$:
$$
\sqrt[4]{z}\;=\; r^{1/4}\,e^{\,i\,\operatorname{Arg}(z)/4}, \qquad z = r e^{i\theta}.
$$

**Raiz principal** $$k = 0$$

Para el anterior ejercicio, 
$$
w_0=2^{7/16}{e^{i\frac{\pi}{32}}}\approx 1.349+0.133i.
$$
Las demás raíces se obtienen rotando sucesivamente $45°$ (es decir, sumando ${\pi/4}$ al angulo) alrededor del circulo de radio $2^{7/16}$.

## Aproximaciones numéricas

Por aritmética de punto flotante, $w_k^4$ no es **exactamente** $z$. El residuo $|w_k^4 - z|$ debe ser pequeño.

Para el ejemplo anterior, todas las raíces están sobre el círculo de centro $(0,0)$ y radio $r=1.3543$, formando un **octagono regular**. El primer punto esta en el angulo ${\pi}/32  (\approx 5.625°)$ y luego vas sumando ${\pi}/4$ 


**Coordenadas aproximadas (para trazar)**
```{python}
def signo_md(x: float, dec: int = 4) -> str:
    """
    Devuelve el número con signo +/− y 'dec' decimales, usando el
    signo unicode '−' para negativos.
    """
    s = f"{abs(x):.{dec}f}"
    return ("+" + s) if x >= 0 else ("−" + s)  # nota: '−' U+2212

# Encabezado
print(f"z = {z}  |z|={abs(z):.6f}  arg(z)={cmath.phase(z):.6f} rad")

# Tabla Markdown
print("\n| k |  Real (Wk) | Imaginario |")
for k, w in enumerate(W):
    re = signo_md(w.real, 4)
    im = signo_md(w.imag, 4)
    print(f"| {k} | {re:>10} | {im:>10} |")
```
## Grafica de raices
```{python}
import cmath
import math
import matplotlib.pyplot as plt

def graficar_raices(z: complex, n: int, conectar=True, rayos=False, circulo=True):
    """Grafica raíces n-ésimas de z y (opcional) las conecta en orden angular."""
    roots = raices_n_esimas(z, n)
    if not roots:
        return
    radio = abs(roots[0])

    # Ordenar por ángulo para conectar correctamente
    roots_sorted = sorted(roots, key=lambda w: cmath.phase(w))

    # Coordenadas
    xs = [w.real for w in roots_sorted]
    ys = [w.imag for w in roots_sorted]

    # Cerrar el polígono si se conecta
    if conectar and n > 1:
        xs.append(xs[0])
        ys.append(ys[0])

    # Gráfica
    fig, ax = plt.subplots(figsize=(5,5))

    # Círculo guía
    if circulo:
        ax.add_artist(plt.Circle((0,0), radio, fill=False, linestyle="--", color="red", lw=1))

    # Puntos
    ax.scatter([w.real for w in roots], [w.imag for w in roots],
               color="blue", s=60, zorder=3, label="Raíces")

    # Conexión (polígono)
    if conectar and n > 1:
        ax.plot(xs, ys, color="blue", lw=1.5, alpha=0.9, label="Polígono")

    # Rayos desde el origen (opcional)
    if rayos:
        for w in roots:
            ax.plot([0, w.real], [0, w.imag], color="green", lw=0.8, zorder=1)

    # Etiquetas k (según orden original de generación)
    for k, w in enumerate(roots):
        ax.text(w.real, w.imag, f"k={k}", fontsize=9, va="bottom", ha="left")

    # Ejes y estilo
    ax.axhline(0, color="black", lw=0.8)
    ax.axvline(0, color="black", lw=0.8)
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlabel("Parte real")
    ax.set_ylabel("Parte imaginaria")
    ax.grid(alpha=0.3)
    ax.legend(loc="upper right")
    plt.tight_layout()
    plt.show()

# ==== Ejemplo del ejercicio ====
z = (16j)/(1+1j)  # (16 i)/(1+i)
n = 8
graficar_raices(z, n, conectar=True, rayos=True, circulo=True)

```